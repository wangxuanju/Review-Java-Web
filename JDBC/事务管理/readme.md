# 事务管理与开发
## 事务：
事务是并发控制的基本单位，指作为单个逻辑单元执行的一系列操作，而这些逻辑工作单元需要满足ACID特性。

原子性：A整个交易必须是一个整体，要么全做，要么都不做。

一致性：C

隔离性：I

持久性：D

## JDBC的事务控制：
Connection

--setAutoCommit();开启事务

--commit()提交事务

--rollback()回滚事务

### 检查点
Connection
--setSavePoint();
--


## 事务并发执行：
脏读——读取一个事务未提交的更新。

不可重复读——同一个事务两次读取相同的记录，结果不一样。

幻读——两次读取的结果包含的行记录不一样。

### 事务隔离级别：
读未提交
读提交
重复读
串行化


#### MySQL默认事务隔离级别为repeatable read.
#### 事务隔离级别越高，数据库性能越差。

### 设置隔离级别
Coonection

--getTransactionIsolation();

--setTransactionIsolation();



## 事务持锁
死锁：是两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。
## 死锁产生的必要条件：
### 互斥
	并发执行的事务为了进行必要的隔离保证执行正确，在事务结束前，需要对修改的数据记录持锁，保证多个事务对相同的数据记录串行修改。
	对于大型并发系统无法避免。
### 请求与保持
--已经持有一个资源锁，等待另外一个资源锁
--死锁仅发生在请求两个或者两个以上的锁对象。
--由于应用需要，难以消除。
### 不剥夺
--已经获得锁资源的事务，在未执行前，不能被强制剥夺，只能使用完成时，由事务自己释放。
--一般用于已经出现死锁时，通过破坏该条件达到解除死锁的目的。
--数据库系统通常通过一定的死锁检测机制发现死锁，强制回滚代价相对较小的事务，达到解除死锁的目的。
## 死锁产生的必要条件
### 环路等待
--发生死锁时，必然存在一个事务——锁的环形链。

--按照同一顺序获取锁，可以破坏该条件。

--通过分析死锁事务之间的锁竞争关系，调整SQL的顺序，达到消除死锁的目的。
## 加锁方式：
### 外部加锁（掌握）
--由应用程序添加，锁依赖关系较容易分析
--共享锁（s）:select * from talble lock in share mode
--排他锁（X）：select * from talbe for update

### 内部加锁（基本掌握）
--为了实现ACID特性，由数据库系统内部自动添加

--加锁规则繁琐，与SQL执行计划、事务隔离级别、表索引结构有关。

## 哪些SQL需要持有锁：
--Innodb实现了多版本控制（MVCC），支持不加锁快照读。

--Select * from table wherw …

--能够保证同一个Select结构集是一致的

--不能保证同一个事务内部，Select语句和其它语句的数据一致性，如果业务需要，需通过外部显式加锁。

### 当前读
--select * from table lock in share mode

--select * from talbe for update

--update from table set..

--insert into..

--Delete from table..

### 分析死锁的常用办法
Show engine innodb status.
