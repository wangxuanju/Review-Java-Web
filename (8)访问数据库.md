# 一、JDBC简介


# 二、通过JDBC API访问数据库的JSP范例程序
```java
<!--首先导入一些必要的packages-->
<%@ page import="java.io.*"%>
<%@ page import="java.util.*"%>
<!--告诉编译器使用SQL包-->
<%@ page import="java.sql.*"%>
<!--设置中文输出-->
<%@ page contentType="text/html; charset=GB2312" %>

<html>
<head>
  <title>dbaccess.jsp</title>
</head>
<body>
<%
try{

  Connection con;
  Statement stmt;
  ResultSet rs;
  
  //加载驱动程序，下面的代码加载MySQL驱动程序
  Class.forName("com.mysql.jdbc.Driver");
  //注册MySQL驱动程序
  DriverManager.registerDriver(new com.mysql.jdbc.Driver());
  
  //用适当的驱动程序连接到数据库
  String dbUrl =  "jdbc:mysql://localhost:3306/BookDB?useUnicode=true&characterEncoding=GB2312";
  String dbUser="dbuser";
  String dbPwd="1234";
  
  //建立数据库连接
  con = java.sql.DriverManager.getConnection(dbUrl,dbUser,dbPwd);
  //创建一个SQL声明
  stmt = con.createStatement();
  //增加新记录
  stmt.executeUpdate("insert into BOOKS (ID,NAME,TITLE,PRICE) values('999','Tom','Tomcat Bible',44.5)");
                                                       
  //查询记录
  rs = stmt.executeQuery("select ID,NAME,TITLE,PRICE from BOOKS");
  //输出查询结果
  out.println("<table border=1 width=400>");
  while (rs.next()){
    String col1 = rs.getString(1);
    String col2 = rs.getString(2);
    String col3 = rs.getString(3);
    float col4 = rs.getFloat(4);
    //打印所显示的数据
    out.println("<tr><td>"+col1+"</td><td>"+col2+"</td><td>"+col3+"</td><td>"+col4+"</td></tr>");
  }
  out.println("</table>");

  //删除新增加的记录
  stmt.executeUpdate("delete from BOOKS where ID='999'");

  //关闭数据库连接
  rs.close();
  stmt.close();
  con.close();
}catch(Exception e){out.println(e.getMessage());}

%>
</body>
</html>
```
# 三、bookstore应用通过JDBC API访问数据库
BookDB类负责访问数据库，提供了操纵数据库的所有方法。在BookDB类的构造方法中通过Class.forName()方法装载MYSQL的JDBC驱动器：
```java
public BookDB() throws Exception{
    Class.forName(“com.mysql.jdbc.Driver”)；
}
```
在每次访问数据库时，都调用BookDb类自身getConnection()方法，在这个方法中建立和数据库的连接，并返回Connection对象：
```java
public Connection getConnection() throws Exception{
    return java.sql.DriverManager.getConnecion(dbUrl,dbUser,dbPwd);
}
```
当数据库访问结束后，应该依次关闭ResultSet/PreparedStatement(或Staement）和Connection对象，从而释放数据库连接占用的数据。在BookDB类中定义了3个方法，它们分别关闭这3种对象：
```java
closeResultSet(ResultSet rs)
closePrepStmt(PrepareStatement prepStmt)
closeConnection(Connection con)
```
为了确保在数据库访问结束后，closeConnection()方法一定被执行，BookDB类中的 所以访问数据库的方法都采用这种结构;
```java
Connection con=null;
PreparedStatement prepStmt=null;
ResultSet rs=null;
try{
    con=getConnection();
    //访问数据库
    ...
}finally{
    closeRsultSet(rs);
    closePrepStem(prepStmt);
    closeConnection(con);
}
```
# 四、数据源简介
JDBC数据源2.0提供了javax.sql.DataSource接口，负责建立与数据库的连接。
## 数据源和JNDI资源
JNDI技术是一种将对象和名字绑定的技术，外部程序可以通过名字来获得某个对象的引用。

DataSource对象通常是由Servlet容器提供，直接使用Servlet容器提供的DataSource对象即可。

在javax.naming包中提供了Context接口，该接口提供了将对象和名字绑定,以及通过名字来检索对象的方法。
# 五、程序中访问数据源
javax.naming.Context提供了查找JDNI资源的接口，例如通过以下代码获得jdbc/BookDB资源的引用:
```java
Context ctx = new InitialContext();
DateSource ds = (DataSource)ctx.lookup("java:comp/env/jdbc/BookDB");
//得到DataSource对象的引用后，可以通过DateSource的getConnection()方法获得数据库连接对象Connection
connection con = ds.getConnection();
当程序结束数据库访问之后，应该调用Connection对象的close()方法，及时将Connection对象返回数据库连接池，使Connection对象恢复到空闲状态。
```
## 通过数据源连接数据库的JSP范例程序
```java
<!--首先导入一些必要的包-->
<%@ page import="java.io.*"%>
<%@ page import="java.util.*"%>
<%@ page import="java.sql.*"%>
<%@ page import="javax.sql.*"%>
<%@ page import="javax.naming.*"%>
<!--设置中文输出-->
<%@ page contentType="text/html; charset=GB2312" %>
<html>
<head>
  <TITLE>dbaccess1.jsp</TITLE>
</head>
<body>
<%
try{
  Connection con;
  Statement stmt;
  ResultSet rs;
 
 //重点的是下面的几行代码
  //建立数据库连接
  Context ctx = new InitialContext();
  DataSource ds =(DataSource)ctx.lookup("java:comp/env/jdbc/BookDB");
  con = ds.getConnection();

  //创建一个SQL声明
  stmt = con.createStatement();
  //增加新记录
  stmt.executeUpdate("insert into BOOKS(ID,NAME,TITLE,PRICE) values ('999','Tom','Tomcat Bible',44.5)");

  //查询记录
  rs = stmt.executeQuery("select ID,NAME,TITLE,PRICE from BOOKS");
  //输出查询结果
  out.println("<table border=1 width=400>");
  while (rs.next()){
    String col1 = rs.getString(1);
    String col2 = rs.getString(2);
    String col3 = rs.getString(3);
    float col4 = rs.getFloat(4);
    
    //转换字符编码
    col1=new String(col1.getBytes("ISO-8859-1"),"GB2312");
    col2=new String(col2.getBytes("ISO-8859-1"),"GB2312");
    col3=new String(col3.getBytes("ISO-8859-1"),"GB2312");

    //打印所显示的数据
    out.println("<tr><td>"+col1+"</td><td>"+col2+"</td><td>"+col3+"</td><td>"+col4+"</td></tr>");
  }

  out.println("</table>");

  //删除新增加的记录
  stmt.executeUpdate("delete from BOOKS where ID='999'");

  //关闭结果集、SQL声明、数据库连接
  rs.close();
  stmt.close();
  con.close();
}catch (Exception e) {out.println(e.getMessage());e.printStackTrace();
}

%>
</body>
</html>
```
## bookstore应用通过数据源连接数据库
为了提高数据库的效率，通过数据库源来访问数据库。对于每一个需要访问数据库的客户请求，BookDB类只需从Servlet容器提供的数据源的数据库连接池中取出一个空闲状态的连接即可。
在BookDB类的构造方法中通过Context().lookup()方法获得DataSource的引用，并把它保存在成员变量ds中。
在每次访问数据库时，都调用BookDB类自身的getConnection()方法，该方法从DataSource的数据库连接池中取出一个空闲状态的连接。
```java
public Connection getConnection(){
    try{
        return ds.getConnextion();
    }catch(Exception e){
        e.printStackTrace();
        return null;
    }
}
```
当数据库访问结束后，应该依次关闭ResultSet/PreparedStatement(或Statement)和Connection对象。在BookDB类中定义了三个方法，分别关闭这三种对象。
```java
closeResultSet(ResultSet rs)
closePrepStatement(PrepareStatement prepStmt)
closeConnection(Connection con)
```
以上closeConnection()方法把数据库连接放回数据库连接池，使它恢复空闲状态，从而能被重复利用。
为了确保在数据库访问结束后，closeConnection()方法一定被执行，BookDB类中的所有访问数据库的方法采用如下结构;
```java
Connection con=null;
PreparedStatement prepStmt=null;
ResultSet rs=null;
try{
    con=getConnection();
    //访问数据库
    ...
}finally{
    closeResultSet(rs);
    closePrepStmt(prepStmt);
    closeConnection(con);
}
```
代码BookDB.java  P249
# 六、处理中文编码
通过以下两种方式之一把参数转换为中文字符编码。
（1）当请求方式为“POST”时，请求参数位于请求正文中（因此可以先把请求正文的字符编码设为"GB2312"，然后再读取请求参数）。
```java
<%
if(request.getMethod().equealsIgnoreCase("POST")){
    //把请求正文的编码设为“GB2312”
    request.setCharacterEncoding("GB2312");
     //直接读取采用GB2312编码的username请求参数
    STring username=request.getParameter("username");
}
%>
```
当请求方式为GET时，请求参数位于请求头的URI中（此时request.setCharacterEncoding("GB2312"）无法改变请求参数的字符编码）。

（2）先读取请求参数，再进行字符编码转换，这种方法适用于任何请求方式。（第二种用法经典）
```java
<%
    String username=request.getParamter("username");
    //进行字符编码转换
    if(username!=null){
        username=new String(username.getBytes("ISO8859-1","GB2312");
%>
```
# 八、分页显示批量数据*
